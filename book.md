# C语言：
## 6.1.1 数据类型
>* 整数（包含逻辑）
>* 浮点数
>* 指针
>* 自定义
## 6.1.2 整数
#### char , short , int , long , long long 
> * 1-16个字节。分别为1，2，4，8，8
    int与long的字节长度与编译器有关
> * 输入输出：<=int 用%d
    \>int用%ld

    printf("%d",sizeof(int));
    //显示int字节

>整数的内部表达：
>* 补码:在计算机二进制中实现负数
>* 补码+原码=溢出0
>* (1)00000000-00000001=11111111->-1
所以

    char=255
    //二进制11111111=254
    printf("%d,c");
    //输出结果为-1
    unsigned char c=255
    //在输出时，结果就会显示255U
>* int:-2^32-1 ~ 2^32-1 -1
>* char:-128~127
    127+1=-128
    -128-1=127

无特殊需求，定义变量用int就好。
>逃逸字符：
>>\b:用后部分覆盖前一个字符
\t:到下一个表格位
\n:换行
\r:回车

>* 自动类型转换：
>>运算符两边常变量类型不一致，C会将小的范围类型转换为大类型
对于printf来说，小于int的类型会自动转换为int,float会自动转换为double.
但scanf不会
>* 强制类型转换：
>>较大->较小
(类型)值        (int)100.2
注意安全性，小变量不能总是表示大变量
不会更改变量，只会运算出一个新结果
优先级高于四则运算


### 6.2.1 逻辑
#### bool , true , false

    #include<stdbool.h>
>逻辑运算：
>* 结果只有0，1
>* ！ 取非
>* && 与
>* || 或
>* ,
>* 优先级：!>&&>||
    不要把赋值写进表达式


## 6.1.7 浮点数
#### double , float
|  | float | double |
| :-----:| :----: | :----: |
| 范围 | 小，7位 | 大，十五位 |
| 误差范围 | 大 | 小 |
| printf | %f,%e | %f,%e |
| scanf | %f | %lf |
    -5.67E+16
    //科学计数法，16是指数，eE均可
浮点数是离散的数，存在误差。四则运算并不准确

    printf("%.3f\n",-0.0049);
    //四舍五入，输出小数点后三位，结果为0.005
>%.nf 指定输出精度——四舍五入
>* printf输出inf表示超出范围的浮点数——正无穷
>* 输出nan表示不存在的浮点数
    12.0/0.0->nan
>* 在小数后+f表示此为float，否则默认为double

##7.1.1 函数
* 代码复制是程序质量不良的表现
>构成：返回类型+名称+（参数）{
    ruturn+返回值
      }
>* 无参数也要加（）
>* 调用时函数名+（参数）；
>* 前有 类型声明 时可以将函数本体写在程序末尾

>调用函数：
>* max(max(35,45),55)是正确的
>* 在int函数里输入double参数，参数会被四舍五入，造成数据损失
>* C在调用函数时，只能传值给函数，而非代入变量参数
>>本地变量:
生存期，作用域->{}——块
定义在块内，块与块不相通
块外定义的变量在块里仍有效，块内定义会覆盖块外同名变量
>* 没有参数：void f (void)
>* C不允许函数内定义另一个函数
>* int main()也是函数
>* return 0代表运行结束，非零即代表出错

## 8.1.1 数组
>构成：类型+名称+[元素数量（整数）]

    int number [100];
    //此数组从number[0]-number[99]个元素存数
    int a[]={1，2，3，4，5，6}
    //数组会自动数出数据个数
    printf("%lu\n",sizeof(a));
    //得出数组总字节
    printf("%lu\n",sizeof(a[0]));
    //得出数组单个字节
>sizeof(a)/sizeof(a[0]) 得出数组单元个数
>* 数组本身不能被赋值
>* int b[]=a 是错的

>遍历数组：
通常使用for循环。循环变量i从0到小于数组长度。这样循环体内最大的i正好是数组最大的有效下标
>* 数组作为函数参数时，往往必须在用另一个参数传入数组的大小

    for(i=0;i<length;i++>){
        b[i]=a[i];
    }
    //遍历数组，从而使数组相等
    for(i=0;i<)



## 9.1.2 指针
指针就是保存地址的变量

    int i;
    int*p=&i;
    //p是指针，p存储i的地址，p指向i