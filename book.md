# C语言：
## 6.1.1 数据类型
>* 整数（包含逻辑）
>* 浮点数
>* 指针
>* 自定义
## 6.1.2 整数
#### char , short , int , long , long long 
> * 1-16个字节。分别为1，2，4，8，8
    int与long的字节长度与编译器有关
> * 输入输出：<=int 用%d
    \>int用%ld

    printf("%d",sizeof(int));
    //显示int字节

>整数的内部表达：
>* 补码:在计算机二进制中实现负数
>* 补码+原码=溢出0
>* (1)00000000-00000001=11111111->-1
所以

    char=255
    //二进制11111111=254
    printf("%d,c");
    //输出结果为-1
    unsigned char c=255
    //在输出时，结果就会显示255U
>* int:-2^32-1 ~ 2^32-1 -1
>* char:-128~127
    127+1=-128
    -128-1=127

无特殊需求，定义变量用int就好。
>逃逸字符：
>>\b:用后部分覆盖前一个字符
\t:到下一个表格位
\n:换行
\r:回车

>* 自动类型转换：
>>运算符两边常变量类型不一致，C会将小的范围类型转换为大类型
对于printf来说，小于int的类型会自动转换为int,float会自动转换为double.
但scanf不会
>* 强制类型转换：
>>较大->较小
(类型)值        (int)100.2
注意安全性，小变量不能总是表示大变量
不会更改变量，只会运算出一个新结果
优先级高于四则运算


### 6.2.1 逻辑
#### bool , true , false

    #include<stdbool.h>
>逻辑运算：
>* 结果只有0，1
>* ！ 取非
>* && 与
>* || 或
>* ,
>* 优先级：!>&&>||
    不要把赋值写进表达式


## 6.1.7 浮点数
#### double , float
|  | float | double |
| :-----:| :----: | :----: |
| 范围 | 小，7位 | 大，十五位 |
| 误差范围 | 大 | 小 |
| printf | %f,%e | %f,%e |
| scanf | %f | %lf |
    -5.67E+16
    //科学计数法，16是指数，eE均可
浮点数是离散的数，存在误差。四则运算并不准确

    printf("%.3f\n",-0.0049);
    //四舍五入，输出小数点后三位，结果为0.005
>%.nf 指定输出精度——四舍五入
>* printf输出inf表示超出范围的浮点数——正无穷
>* 输出nan表示不存在的浮点数
    12.0/0.0->nan
>* 在小数后+f表示此为float，否则默认为double

##7.1.1 函数
* 代码复制是程序质量不良的表现
>构成：返回类型+名称+（参数）{
    ruturn+返回值
      }
>* 无参数也要加（）
>* 调用时函数名+（参数）；
>* 前有 类型声明 时可以将函数本体写在程序末尾

>调用函数：
>* max(max(35,45),55)是正确的
>* 在int函数里输入double参数，参数会被四舍五入，造成数据损失
>* C在调用函数时，只能传值给函数，而非代入变量参数
>>本地变量:
生存期，作用域->{}——块
定义在块内，块与块不相通
块外定义的变量在块里仍有效，块内定义会覆盖块外同名变量
>* 没有参数：void f (void)
>* C不允许函数内定义另一个函数
>* int main()也是函数
>* return 0代表运行结束，非零即代表出错

## 8.1.1 数组
>构成：类型+名称+[元素数量（整数）]

    int number [100];
    //此数组从number[0]-number[99]个元素存数
    int a[]={1，2，3，4，5，6}
    //数组会自动数出数据个数
    printf("%lu\n",sizeof(a));
    //得出数组总字节
    printf("%lu\n",sizeof(a[0]));
    //得出数组单个字节
>sizeof(a)/sizeof(a[0]) 得出数组单元个数
>* 数组本身不能被赋值
>* int b[]=a 是错的

>遍历数组：
通常使用for循环。循环变量i从0到小于数组长度。这样循环体内最大的i正好是数组最大的有效下标


    for(i=0;i<length;i++>){
        b[i]=a[i];
    }
    //遍历数组，从而使数组相等
    for(i=0;i<number;i++){
        count[i]=0;
    }
    //初始化数组，使元素均等于零

>* 数组作为函数参数时，往往必须在用另一个参数传入数组的大小
>* 不能在[]中给出数组大小，也不能用sizeof算

    int search (int key,int a[],int length)
    //length 数组长度
    prime[cnt++]=i;
    //将i写入prime数组中cnt的位置后cnt指向下一个位置

>二维数组：
行数可省，列数不可省

     int a [3][5];
    //a是一个三行五列的矩阵
    for(i=0;i<3;i++){
        for(j=0;j<5;j++){
            a[i][j]=i*j;
        }
    }
    //遍历二维数组
## 9.1.2 指针
指针就是保存地址的变量

    int i;
    int*p=&i;
    //p是指针，p存储i的地址，p指向i

>* 作为参数的指针

    voidf(int*p);
    //调用此函数时，（）内应填地址
    //即int i=0；f(&i);

>&即可获得变量的地址
>*p即可访问指针存储地址对应的变量
&\*互为反作用，可互相抵消
>* 以指针改变过后，变量即会改变
    与只传数值的int函数不同

>指针的应用：
>1. 传入较大数据用作参数
>2. 传入数据后对其操作
>3. 函数返回不止一个结果
>4. 用函数修改不止一个变量
>5. 动态申请内存

>* 函数参数表内数组是指针，函数内部的数组都是指针
>* 数组变量是特殊的指针。
>* 将变量看作只含1个元素的数组，有效下标既是p[0]

>const与指针：
>> const在*前表示所指东西不能由指针修改
>> const在*后表示指针不可修改
>>* 当传递大型数据时，用指针传递地址节省空间，但指针可能会对数据进行修改。————const
>* 数据是一种const指针，即只能指向此数组

> 指针运算:
>* 指针加一即知道下一个单元去，即加字节
>>*p->ac[0]
>>*(p+1)->ac[1]
>>*(p+n)->ac[n]
>* 指针减法不是显示地址差
>>*p++:取出派代表到变量后，将p移到下一变量去

>关于指针的数组遍历：

    char ac[]={1,2,3,4,-1};
    char *p=&ac[0];
    for(p=ac;*p!=-1;p++){
        printf("%d",*p);
    }
    for(p=ac;*p!=-1;){
        printf("%d",*p++);
    }
    while(*p!=-1){
        printf("%d",*p++);
    }
    //三种遍历，一个结果

>数组中单元地址是线性递增的,指针可以比较大小
>无论指向什么类型，所有指针的大小都是一样的。但指向不同类型的指针不能直接进行互相赋值
>0地址：用NULL

>指针类型转换：
>* void*表示不知道向什么类型的指针
>* int\*p =&i；void\*q=（void*）p;

>动态内存分配：
>* C99：int a [number];
>* 头文件#include <stdlib.h>
    a=(int*)malloc(number*sizeof(int));
    结尾free(a)
>* 申请失败/无空间，返回NULL
>* 有借有还。应free原地址a（数组）

    #include <stdlib.h>
    #include <stdio.h>
    int main()
    {
        viod*p;
        int cnt=0;
        while((p=malloc(100*1024*1024))){
            cnt++
        }
        printf("分配%d00MB空间"，cnt);
        return 0;
    }

